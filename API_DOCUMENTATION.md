# online_python_ide Backend API Documentation

This document provides details for frontend developers on how to interact with the `online_python_ide` backend API. The API allows for the execution of Python code in a secure, isolated environment and retrieves standard output, standard error, exit codes, and any generated output files.

## API Endpoint

### Execute Python Code

*   **URL:** `/api/v1/execute`
*   **Method:** `POST`
*   **Content-Type:** `application/json`

#### Request Body

The request body must be a JSON object with the following structure:

```json
{
  "code": "your python code string here",
  "input_data": "optional string for stdin, lines separated by \\n"
}
```

*   **`code`** (string, required): The Python code to be executed. Multi-line code should be provided as a single string with newline characters (`\n`).
*   **`input_data`** (string, optional, nullable): Any standard input that the Python script expects. If the script uses `input()`, provide the input here. Multiple lines of input should be separated by newline characters (`\n`). If no input is needed, this field can be `null` or omitted.

**Example Request:**

```json
{
  "code": "name = input('Enter your name: ')\nprint(f'Hello, {name}!')\n\n# Create a file\nwith open('/app/outputs/greeting.txt', 'w') as f:\n    f.write(f'Greetings to {name}')\nprint('File created.')",
  "input_data": "Roo"
}
```

#### Response Body

The response will be a JSON object.

**On Success (HTTP 200 OK):**

The response object will have the following structure:

```json
{
  "stdout": "string or null",
  "stderr": "string or null",
  "error_details": null,
  "exit_code": "integer (usually 0 for success)",
  "output_files": [
    {
      "filename": "string",
      "content_base64": "string (base64 encoded file content)"
    }
  ] or null
}
```

*   **`stdout`** (string | null): The standard output produced by the script. Will be `null` if no stdout.
*   **`stderr`** (string | null): The standard error produced by the script. Note: Script execution errors (e.g., Python exceptions) will appear here.
*   **`error_details`** (null): This field will be `null` if the API call itself was successful and the script execution started (even if the script itself had errors or a non-zero exit code).
*   **`exit_code`** (integer | null): The exit code of the executed Python script. `0` typically indicates success. Other values indicate script-level errors.
*   **`output_files`** (array of `OutputFile` objects | null): A list of files generated by the script in its designated output directory (`/app/outputs` within the container). Each `OutputFile` object has:
    *   **`filename`** (string): The name of the file (e.g., `result.txt`, `plot.png`).
    *   **`content_base64`** (string): The content of the file, base64 encoded. The frontend will need to decode this to use the file content.

**Example Successful Response (for the example request above):**

```json
{
  "stdout": "Enter your name: Hello, Roo!\nFile created.",
  "stderr": "",
  "error_details": null,
  "exit_code": 0,
  "output_files": [
    {
      "filename": "greeting.txt",
      "content_base64": "R3JlZXRpbmdzIHRvIFJvbwo=" 
    }
  ]
}
```
*(Base64 for "Greetings to Roo")*

**On API Error or Execution Environment Error (HTTP 200 OK, but with `error_details` populated):**

If there's an issue with the API request itself, the Docker environment, timeouts, or other server-side problems preventing or interrupting successful script execution, the `error_details` field will be populated. The `stdout`, `stderr`, and `output_files` might be `null` or contain partial data depending on when the error occurred. The `exit_code` will typically be non-zero (often `-1` for these types of errors).

```json
{
  "stdout": "string or null (may contain partial output before error)",
  "stderr": "string or null (may contain partial output or error context)",
  "error_details": {
    "type": "ErrorType (enum string)",
    "message": "string (descriptive error message)"
  },
  "exit_code": "integer (usually -1 for server/infra errors)",
  "output_files": null 
}
```

*   **`error_details.type`** (string enum): Categorizes the error. Possible values:
    *   `"InfrastructureError"`: Problems with the Docker setup, image building, etc.
    *   `"ScriptTimeoutError"`: The user's script exceeded the execution time limit (currently 10 seconds).
    *   `"InputError"`: Failure to provide necessary input to the script (e.g., error writing to stdin).
    *   `"FileTransferError"`: Error transferring the script code into the execution environment.
    *   `"InternalServerError"`: An unexpected error occurred on the server.
*   **`error_details.message`** (string): A human-readable message describing the error.

**Example Error Response (Timeout):**

```json
{
  "stdout": "Script started, about to sleep...",
  "stderr": "\n--- Execution terminated (timeout: 10s) ---",
  "error_details": {
    "type": "ScriptTimeoutError",
    "message": "Execution timed out after 10 seconds."
  },
  "exit_code": -1,
  "output_files": null
}
```

#### Handling Output Files

If the `output_files` array is present and not empty, the frontend can iterate through it. For each file:
1.  Get the `filename`. This can be used to display the file name to the user or to infer the file type (e.g., `.txt`, `.png`, `.jpg`).
2.  Get the `content_base64`. This string needs to be base64 decoded.
    *   For text files (e.g., `.txt`, `.csv`, `.json`), the decoded bytes can then be UTF-8 decoded into a string for display.
    *   For image files (e.g., `.png`, `.jpg`), the decoded bytes represent the image data. This can be used to construct a data URL (e.g., `data:image/png;base64,${content_base64}`) for display in an `<img>` tag.
    *   For other binary files, the frontend might offer a download option.

#### Important Considerations for Frontend

*   **Execution Time Limit:** User scripts are limited to approximately 10 seconds of execution time. Scripts exceeding this will be terminated, and a `ScriptTimeoutError` will be returned.
*   **Resource Limits:** Scripts run with memory (128MB) and process count (100 PIDs) limits. While users won't get direct feedback on hitting these other than potential script crashes or non-zero exit codes, it's good to be aware.
*   **No Network Access:** Scripts executed by this API do **not** have access to the internet or any external network resources.
*   **File Output Path:** Scripts should write any desired output files to the `/app/outputs/` directory within their execution environment. Only files in this directory will be retrieved.
*   **Error Display:**
    *   If `error_details` is present, display this as a primary error to the user.
    *   If `error_details` is `null` but `stderr` is present and/or `exit_code` is non-zero, this indicates an error or issue within the user's Python script itself. Display `stderr` prominently.

## Backend Workflow Overview (for context)

1.  The API receives the Python code and optional stdin data.
2.  The backend ensures a secure Docker image (named `online-python-executor:latest`) is available, building it if necessary. This image contains a minimal Python environment.
3.  The user's Python code is packaged and securely placed into a new, isolated Docker container (as `/app/user_script.py`).
4.  The container is started with strict resource limits (CPU time via timeout, memory, PID count) and no network access. The script runs as a non-privileged user.
5.  If `input_data` was provided, it's streamed to the script's standard input.
6.  The script executes. Its `stdout` and `stderr` are captured.
7.  After execution (or timeout), any files created by the script in the `/app/outputs/` directory within the container are retrieved.
8.  The container is stopped and removed.
9.  The API formats and returns the `stdout`, `stderr`, `exit_code`, retrieved `output_files` (base64 encoded), and any `error_details` to the client.

This overview should help in understanding the lifecycle and constraints when building the frontend experience.