"""
Main application file for the PyExecute API Gateway.
This service receives code execution requests and forwards them
to a separate Docker Executor Service.
"""

from dotenv import load_dotenv # Add this import
load_dotenv() # Load environment variables from .env file at project root

import logging
import os
import httpx # For making HTTP requests to the executor service
from typing import List, Optional, Dict
from enum import Enum

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

# Configure basic logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# --- Environment Configuration ---
APP_ENV = os.getenv("APP_ENV", "development").lower()
EXECUTOR_SERVICE_URL = os.getenv("EXECUTOR_SERVICE_URL") # e.g., http://localhost:8080 or deployed URL
GATEWAY_EXECUTOR_AUTH_TOKEN = os.getenv("GATEWAY_EXECUTOR_AUTH_TOKEN") # For calling the executor
AUTH_HEADER_NAME_FOR_EXECUTOR = "X-Internal-Auth-Token" # Must match what executor expects

if not EXECUTOR_SERVICE_URL:
    logger.critical(
        "CRITICAL: EXECUTOR_SERVICE_URL environment variable is not set. " +
        "The API Gateway will not be able to connect to the Executor Service."
    )
    # The application will still start, but calls to /api/v1/execute will fail
    # if EXECUTOR_SERVICE_URL remains unset.

logger.info(f"FastAPI Gateway: APP_ENV='{APP_ENV}', EXECUTOR_SERVICE_URL='{EXECUTOR_SERVICE_URL if EXECUTOR_SERVICE_URL else "NOT SET"}'")

# --- FastAPI Application ---
app = FastAPI(
    title="PyExecute API Gateway",
    description="API gateway for executing Python code via a separate executor service.",
    version="0.1.0", # Keeping version as 0.1.0 as requested
)

# --- CORS Configuration ---
# CORS_ALLOWED_ORIGINS must be explicitly set in all environments. No fallbacks.
raw_allowed_origins = os.getenv("CORS_ALLOWED_ORIGINS")
allowed_origins = []

if raw_allowed_origins:
    allowed_origins.extend([origin.strip() for origin in raw_allowed_origins.split(',') if origin.strip()])
    if allowed_origins:
        logger.info(f"CORS allowed origins loaded from environment: {allowed_origins}")
    else:
        # Env var was set but was empty or only commas/whitespace
        logger.critical("CRITICAL: CORS_ALLOWED_ORIGINS was set but resulted in an empty list. No cross-origin requests will be allowed by this configuration.")
        # allowed_origins remains empty, CORSMiddleware will block if list is empty.
else:
    # Env var was not set at all
    logger.critical("CRITICAL: CORS_ALLOWED_ORIGINS environment variable not set. No cross-origin requests will be allowed by this configuration.")
    # allowed_origins remains empty

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["*"], 
    allow_headers=["*"], 
)

# --- Pydantic Models (Define the API contract of this Gateway) ---
# These models describe what this gateway expects and returns.
# The structure should match what the executor service returns for consistency.

class ErrorType(str, Enum): # Kept for defining this gateway's error detail structure
    INPUT_ERROR = "InputError" # Errors from this gateway's validation
    EXECUTOR_SERVICE_ERROR = "ExecutorServiceError" # Errors calling or from the executor
    INTERNAL_SERVER_ERROR = "InternalServerError" # Errors within this gateway

class ErrorDetail(BaseModel):
    type: ErrorType
    message: str

class OutputFile(BaseModel):
    filename: str
    content_base64: str

class CodeExecutionRequest(BaseModel): # Request to this gateway
    code: str = Field(..., description="The Python code to execute.")
    input_data: Optional[str] = Field(None, description="Optional standard input for the code.")

class CodeExecutionResponse(BaseModel): # Response from this gateway
    stdout: Optional[str] = Field(None, description="Standard output from the code.")
    stderr: Optional[str] = Field(None, description="Standard error from the code.")
    # error_details from executor will be passed through if present, 
    # or this gateway can generate its own.
    error_details: Optional[Dict] = Field(None, description="Details of the error, if one occurred. Structure matches executor's ErrorDetail.")
    exit_code: Optional[int] = Field(None, description="Exit code of the script from executor.")
    output_files: Optional[List[OutputFile]] = Field(None, description="Files generated by the script, from executor.")

# --- API Endpoints ---
@app.post("/api/execute", response_model=CodeExecutionResponse) # Changed path from /api/v1/execute
async def execute_code_via_executor(request: CodeExecutionRequest) -> CodeExecutionResponse:
    if not EXECUTOR_SERVICE_URL:
        logger.critical("Executor service URL (EXECUTOR_SERVICE_URL) is not configured.")
        error_payload = ErrorDetail(type=ErrorType.INTERNAL_SERVER_ERROR, message="Executor service URL is not configured.")
        return CodeExecutionResponse(error_details=error_payload.model_dump(), exit_code=-1)

    if not GATEWAY_EXECUTOR_AUTH_TOKEN:
        logger.critical("Gateway executor auth token (GATEWAY_EXECUTOR_AUTH_TOKEN) is not configured.")
        error_payload = ErrorDetail(type=ErrorType.INTERNAL_SERVER_ERROR, message="Gateway authentication token for executor service is not configured.")
        return CodeExecutionResponse(error_details=error_payload.model_dump(), exit_code=-1)

    executor_request_payload = {"code": request.code, "input_data": request.input_data}
    
    try:
        headers_for_executor = {
            'Content-Type': 'application/json',
            AUTH_HEADER_NAME_FOR_EXECUTOR: GATEWAY_EXECUTOR_AUTH_TOKEN
        }

        executor_endpoint = f"{EXECUTOR_SERVICE_URL}/internal/execute-script"
        # EXECUTION_TIMEOUT_SECONDS is not defined in this file, this was a leftover.
        # The timeout for httpx.AsyncClient should be defined or use its default.
        # Let's use a reasonable default, e.g., 30 seconds, which should be ample for most calls + executor's own timeout.
        async with httpx.AsyncClient(timeout=30.0) as client:
            logger.info(f"Forwarding request to executor service at {executor_endpoint}")
            response = await client.post(
                executor_endpoint,
                json=executor_request_payload,
                headers=headers_for_executor # Send the auth token
            )
            
            # Forward the executor's response (status code and body)
            # The executor service should ideally always return HTTP 200 with its own structured error/success payload.
            # If the executor itself returns 500, we might want to map that to our own error type.
            
            response_data = response.json() # Assuming executor always returns JSON

            if response.status_code != 200:
                logger.error(f"Executor service returned non-200 status: {response.status_code}. Response: {response_data}")
                # Create a specific error detail for this gateway
                gateway_error = ErrorDetail(
                    type=ErrorType.EXECUTOR_SERVICE_ERROR,
                    message=f"Executor service failed with status {response.status_code}. Detail: {response_data.get('error_details', {}).get('message', 'Unknown executor error')}"
                )
                return CodeExecutionResponse(error_details=gateway_error.model_dump(), exit_code=-1)

            # Directly return the (assumed to be CodeExecutionResponse compatible) JSON from executor
            # The Pydantic model CodeExecutionResponse will validate this structure on return.
            return CodeExecutionResponse(**response_data)

    except httpx.RequestError as e:
        logger.error(f"Error calling executor service: {e}", exc_info=True)
        error_payload = ErrorDetail(type=ErrorType.EXECUTOR_SERVICE_ERROR, message=f"Failed to connect to executor service: {str(e)}")
        return CodeExecutionResponse(error_details=error_payload.model_dump(), exit_code=-1)
    except Exception as e:
        logger.exception("Unexpected error in API gateway.")
        error_payload = ErrorDetail(type=ErrorType.INTERNAL_SERVER_ERROR, message=f"An unexpected error occurred in the API gateway: {str(e)}")
        return CodeExecutionResponse(error_details=error_payload.model_dump(), exit_code=-1)

if __name__ == "__main__":
    import uvicorn
    # For local dev, ensure EXECUTOR_SERVICE_URL is set in your env or defaults correctly.
    # And ensure the executor service (Flask app) is running.
    logger.info("Starting PyExecute API Gateway (FastAPI)...")
    uvicorn.run(app, host="0.0.0.0", port=8000) # This gateway runs on port 8000